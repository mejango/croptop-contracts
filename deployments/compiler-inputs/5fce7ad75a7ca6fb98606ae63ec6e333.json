{
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23",
	"id": "5fce7ad75a7ca6fb98606ae63ec6e333",
	"input": {
		"language": "Solidity",
		"settings": {
			"viaIR": false,
			"optimizer": {
				"runs": 100000000,
				"enabled": true
			},
			"metadata": {
				"useLiteralContent": false,
				"bytecodeHash": "ipfs",
				"appendCBOR": true
			},
			"outputSelection": {
				"lib/forge-std/lib/ds-test/src/test.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Base.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdAssertions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdChains.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdCheats.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdError.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdInvariant.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdJson.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdMath.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdStorage.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdStyle.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Test.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Vm.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/console.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/console2.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/interfaces/IMulticall3.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/mocks/MockERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/mocks/MockERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/safeconsole.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721Hook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookProjectDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookStore.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721TokenUriResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721InitTiersConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721Tier.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721TierConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721TiersHookFlags.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721TiersMintReservesConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721TiersSetDiscountPercentConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBDeploy721TiersHookConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBLaunchProjectConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBLaunchRulesetsConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBPayDataHookRulesetConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBPayDataHookRulesetMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBQueueRulesetsConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/abstract/JBPermissioned.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/enums/JBApprovalStatus.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBController.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBDirectory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBDirectoryAccessControl.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFundAccessLimits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPayHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPriceFeed.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPrices.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBProjectUriRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesets.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBSplitHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBSplits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBToken.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTokens.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBConstants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBMetadataResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBAccountingContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBAfterPayRecordedContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBCurrencyAmount.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBFundAccessLimitGroup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRuleset.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetWithMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBSplit.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBSplitGroup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBSplitHookContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBTerminalConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBTokenAmount.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/test/helpers/MetadataResolverHelper.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/JBOwnable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/JBOwnableOverrides.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/interfaces/IJBOwnable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/struct/JBOwner.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/Context.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/CTDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/CTProjectOwner.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/CTPublisher.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/ICTDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/ICTProjectOwner.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/ICTPublisher.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/CTAllowedPost.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/CTDeployerAllowedPost.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/CTPost.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/Test_MetadataGeneration.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				}
			},
			"evmVersion": "paris",
			"libraries": {},
			"remappings": [
				"@sphinx-labs/contracts/=node_modules/@sphinx-labs/contracts/contracts/foundry/",
				"@croptop/core/=/",
				"@arbitrum/=node_modules/@arbitrum/",
				"@bananapus/=node_modules/@bananapus/",
				"@chainlink/=node_modules/@chainlink/",
				"@eth-optimism/=node_modules/@eth-optimism/",
				"@exhausted-pigeon/=node_modules/@exhausted-pigeon/",
				"@offchainlabs/=node_modules/@offchainlabs/",
				"@openzeppelin/=node_modules/@openzeppelin/",
				"@prb/=node_modules/@prb/",
				"@rev-net/=node_modules/@rev-net/",
				"@scroll-tech/=node_modules/@scroll-tech/",
				"@uniswap/=node_modules/@uniswap/",
				"@zksync/=node_modules/@zksync/",
				"base64-sol/=node_modules/base64-sol/",
				"ds-test/=lib/forge-std/lib/ds-test/src/",
				"forge-std/=lib/forge-std/src/",
				"hardhat/=node_modules/hardhat/",
				"solady/=node_modules/solady/",
				"solmate/=node_modules/solmate/",
				"sphinx/=lib/sphinx/packages/contracts/contracts/forge-std/src/"
			]
		},
		"sources": {
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721Hook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\n\ninterface IJB721Hook {\n    function DIRECTORY() external view returns (IJBDirectory);\n    function METADATA_ID_TARGET() external view returns (address);\n    function PROJECT_ID() external view returns (uint256);\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\nimport {IJBRulesets} from \"@bananapus/core/src/interfaces/IJBRulesets.sol\";\n\nimport {IJB721Hook} from \"./IJB721Hook.sol\";\nimport {IJB721TiersHookStore} from \"./IJB721TiersHookStore.sol\";\nimport {IJB721TokenUriResolver} from \"./IJB721TokenUriResolver.sol\";\nimport {JB721InitTiersConfig} from \"../structs/JB721InitTiersConfig.sol\";\nimport {JB721TierConfig} from \"../structs/JB721TierConfig.sol\";\nimport {JB721TiersHookFlags} from \"../structs/JB721TiersHookFlags.sol\";\nimport {JB721TiersMintReservesConfig} from \"../structs/JB721TiersMintReservesConfig.sol\";\nimport {JB721TiersSetDiscountPercentConfig} from \"../structs/JB721TiersSetDiscountPercentConfig.sol\";\n\ninterface IJB721TiersHook is IJB721Hook {\n    event AddPayCredits(\n        uint256 indexed amount, uint256 indexed newTotalCredits, address indexed account, address caller\n    );\n    event AddTier(uint256 indexed tierId, JB721TierConfig tier, address caller);\n    event Mint(\n        uint256 indexed tokenId,\n        uint256 indexed tierId,\n        address indexed beneficiary,\n        uint256 totalAmountPaid,\n        address caller\n    );\n    event MintReservedNft(uint256 indexed tokenId, uint256 indexed tierId, address indexed beneficiary, address caller);\n    event RemoveTier(uint256 indexed tierId, address caller);\n    event SetBaseUri(string indexed baseUri, address caller);\n    event SetContractUri(string indexed uri, address caller);\n    event SetDiscountPercent(uint256 indexed tierId, uint256 discountPercent, address caller);\n    event SetEncodedIPFSUri(uint256 indexed tierId, bytes32 encodedUri, address caller);\n    event SetTokenUriResolver(IJB721TokenUriResolver indexed resolver, address caller);\n    event UsePayCredits(\n        uint256 indexed amount, uint256 indexed newTotalCredits, address indexed account, address caller\n    );\n\n    function RULESETS() external view returns (IJBRulesets);\n    function STORE() external view returns (IJB721TiersHookStore);\n\n    function baseURI() external view returns (string memory);\n    function contractURI() external view returns (string memory);\n    function firstOwnerOf(uint256 tokenId) external view returns (address);\n    function payCreditsOf(address addr) external view returns (uint256);\n    function pricingContext() external view returns (uint256, uint256, IJBPrices);\n\n    function adjustTiers(JB721TierConfig[] calldata tierDataToAdd, uint256[] calldata tierIdsToRemove) external;\n    function initialize(\n        uint256 projectId,\n        string memory name,\n        string memory symbol,\n        string memory baseUri,\n        IJB721TokenUriResolver tokenUriResolver,\n        string memory contractUri,\n        JB721InitTiersConfig memory tiersConfig,\n        JB721TiersHookFlags memory flags\n    )\n        external;\n    function setDiscountPercentOf(uint256 tierId, uint256 discountPercent) external;\n    function setDiscountPercentsOf(JB721TiersSetDiscountPercentConfig[] calldata configs) external;\n    function mintFor(uint16[] calldata tierIds, address beneficiary) external returns (uint256[] memory tokenIds);\n    function mintPendingReservesFor(JB721TiersMintReservesConfig[] calldata reserveMintConfigs) external;\n    function mintPendingReservesFor(uint256 tierId, uint256 count) external;\n    function setMetadata(\n        string calldata baseUri,\n        string calldata contractMetadataUri,\n        IJB721TokenUriResolver tokenUriResolver,\n        uint256 encodedIPFSUriTierId,\n        bytes32 encodedIPFSUri\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookStore.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJB721TokenUriResolver} from \"./IJB721TokenUriResolver.sol\";\nimport {JB721Tier} from \"../structs/JB721Tier.sol\";\nimport {JB721TierConfig} from \"../structs/JB721TierConfig.sol\";\nimport {JB721TiersHookFlags} from \"../structs/JB721TiersHookFlags.sol\";\n\ninterface IJB721TiersHookStore {\n    event CleanTiers(address indexed hook, address caller);\n\n    function balanceOf(address hook, address owner) external view returns (uint256);\n    function defaultReserveBeneficiaryOf(address hook) external view returns (address);\n    function encodedIPFSUriOf(address hook, uint256 tierId) external view returns (bytes32);\n    function encodedTierIPFSUriOf(address hook, uint256 tokenId) external view returns (bytes32);\n    function flagsOf(address hook) external view returns (JB721TiersHookFlags memory);\n    function isTierRemoved(address hook, uint256 tierId) external view returns (bool);\n    function maxTierIdOf(address hook) external view returns (uint256);\n    function numberOfBurnedFor(address hook, uint256 tierId) external view returns (uint256);\n    function numberOfPendingReservesFor(address hook, uint256 tierId) external view returns (uint256);\n    function numberOfReservesMintedFor(address hook, uint256 tierId) external view returns (uint256);\n    function cashOutWeightOf(address hook, uint256[] calldata tokenIds) external view returns (uint256 weight);\n    function reserveBeneficiaryOf(address hook, uint256 tierId) external view returns (address);\n    function tierBalanceOf(address hook, address owner, uint256 tier) external view returns (uint256);\n    function tierIdOfToken(uint256 tokenId) external pure returns (uint256);\n    function tierOf(address hook, uint256 id, bool includeResolvedUri) external view returns (JB721Tier memory tier);\n    function tierOfTokenId(\n        address hook,\n        uint256 tokenId,\n        bool includeResolvedUri\n    )\n        external\n        view\n        returns (JB721Tier memory tier);\n\n    function tiersOf(\n        address hook,\n        uint256[] calldata categories,\n        bool includeResolvedUri,\n        uint256 startingSortIndex,\n        uint256 size\n    )\n        external\n        view\n        returns (JB721Tier[] memory tiers);\n\n    function tierVotingUnitsOf(address hook, address account, uint256 tierId) external view returns (uint256 units);\n    function tokenUriResolverOf(address hook) external view returns (IJB721TokenUriResolver);\n    function totalCashOutWeight(address hook) external view returns (uint256 weight);\n    function totalSupplyOf(address hook) external view returns (uint256);\n    function votingUnitsOf(address hook, address account) external view returns (uint256 units);\n\n    function cleanTiers(address hook) external;\n    function recordAddTiers(JB721TierConfig[] calldata tierData) external returns (uint256[] memory tierIds);\n    function recordBurn(uint256[] calldata tokenIds) external;\n    function recordFlags(JB721TiersHookFlags calldata flag) external;\n    function recordMint(\n        uint256 amount,\n        uint16[] calldata tierIds,\n        bool isOwnerMint\n    )\n        external\n        returns (uint256[] memory tokenIds, uint256 leftoverAmount);\n    function recordMintReservesFor(uint256 tierId, uint256 count) external returns (uint256[] memory tokenIds);\n    function recordRemoveTierIds(uint256[] calldata tierIds) external;\n    function recordSetEncodedIPFSUriOf(uint256 tierId, bytes32 encodedIPFSUri) external;\n    function recordSetDiscountPercentOf(uint256 tierId, uint256 discountPercent) external;\n    function recordSetTokenUriResolver(IJB721TokenUriResolver resolver) external;\n    function recordTransferForTier(uint256 tierId, address from, address to) external;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJB721TokenUriResolver {\n    function tokenUriOf(address nft, uint256 tokenId) external view returns (string memory tokenUri);\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721InitTiersConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\n\nimport {JB721TierConfig} from \"./JB721TierConfig.sol\";\n\n/// @notice Config to initialize a `JB721TiersHook` with tiers and price data.\n/// @dev The `tiers` must be sorted by price (from least to greatest).\n/// @custom:member tiers The tiers to initialize the hook with.\n/// @custom:member currency The currency that the tier prices are denoted in. See `JBPrices`.\n/// @custom:member decimals The number of decimals in the fixed point tier prices.\n/// @custom:member prices A contract that exposes price feeds that can be used to calculate prices in different\n/// currencies. To only accept payments in `currency`, set `prices` to the zero address. See `JBPrices`.\nstruct JB721InitTiersConfig {\n    JB721TierConfig[] tiers;\n    uint32 currency;\n    uint8 decimals;\n    IJBPrices prices;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721Tier.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member id The tier's ID.\n/// @custom:member price The price to buy an NFT in this tier, in terms of the currency in its `JBInitTiersConfig`.\n/// @custom:member remainingSupply The remaining number of NFTs which can be minted from this tier.\n/// @custom:member initialSupply The total number of NFTs which can be minted from this tier.\n/// @custom:member votingUnits The number of votes that each NFT in this tier gets.\n/// @custom:member reserveFrequency The frequency at which an extra NFT is minted for the `reserveBeneficiary` from this\n/// tier. With a `reserveFrequency` of 5, an extra NFT will be minted for the `reserveBeneficiary` for every 5 NFTs\n/// purchased.\n/// @custom:member reserveBeneficiary The address which receives any reserve NFTs from this tier.\n/// @custom:member encodedIPFSUri The IPFS URI to use for each NFT in this tier.\n/// @custom:member category The category that NFTs in this tier belongs to. Used to group NFT tiers.\n/// @custom:member discountPercent The discount that should be applied to the tier.\n/// @custom:member allowOwnerMint A boolean indicating whether the contract's owner can mint NFTs from this tier\n/// on-demand.\n/// @custom:member cannotBeRemoved A boolean indicating whether attempts to remove this tier will revert.\n/// @custom:member cannotIncreaseDiscountPercent If the tier cannot have its discount increased.\n/// @custom:member transfersPausable A boolean indicating whether transfers for NFTs in tier can be paused.\n/// @custom:member resolvedUri A resolved token URI for NFTs in this tier. Only available if the NFT this tier belongs\n/// to has a resolver.\nstruct JB721Tier {\n    uint32 id;\n    uint104 price;\n    uint32 remainingSupply;\n    uint32 initialSupply;\n    uint104 votingUnits;\n    uint16 reserveFrequency;\n    address reserveBeneficiary;\n    bytes32 encodedIPFSUri;\n    uint24 category;\n    uint8 discountPercent;\n    bool allowOwnerMint;\n    bool transfersPausable;\n    bool cannotBeRemoved;\n    bool cannotIncreaseDiscountPercent;\n    string resolvedUri;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721TierConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Config for a single NFT tier within a `JB721TiersHook`.\n/// @custom:member price The price to buy an NFT in this tier, in terms of the currency in its `JBInitTiersConfig`.\n/// @custom:member initialSupply The total number of NFTs which can be minted from this tier.\n/// @custom:member votingUnits The number of votes that each NFT in this tier gets if `useVotingUnits` is true.\n/// @custom:member reserveFrequency The frequency at which an extra NFT is minted for the `reserveBeneficiary` from this\n/// tier. With a `reserveFrequency` of 5, an extra NFT will be minted for the `reserveBeneficiary` for every 5 NFTs\n/// purchased.\n/// @custom:member reserveBeneficiary The address which receives any reserve NFTs from this tier. Overrides the default\n/// reserve beneficiary if one is set.\n/// @custom:member encodedIPFSUri The IPFS URI to use for each NFT in this tier.\n/// @custom:member category The category that NFTs in this tier belongs to. Used to group NFT tiers.\n/// @custom:member discountPercent The discount that should be applied to the tier.\n/// @custom:member allowOwnerMint A boolean indicating whether the contract's owner can mint NFTs from this tier\n/// on-demand.\n/// @custom:member useReserveBeneficiaryAsDefault A boolean indicating whether this tier's `reserveBeneficiary` should\n/// be stored as the default beneficiary for all tiers.\n/// @custom:member transfersPausable A boolean indicating whether transfers for NFTs in tier can be paused.\n/// @custom:member useVotingUnits A boolean indicating whether the `votingUnits` should be used to calculate voting\n/// power. If `useVotingUnits` is false, voting power is based on the tier's price.\n/// @custom:member cannotBeRemoved If the tier cannot be removed once added.\n/// @custom:member cannotIncreaseDiscount If the tier cannot have its discount increased.\nstruct JB721TierConfig {\n    uint104 price;\n    uint32 initialSupply;\n    uint32 votingUnits;\n    uint16 reserveFrequency;\n    address reserveBeneficiary;\n    bytes32 encodedIPFSUri;\n    uint24 category;\n    uint8 discountPercent;\n    bool allowOwnerMint;\n    bool useReserveBeneficiaryAsDefault;\n    bool transfersPausable;\n    bool useVotingUnits;\n    bool cannotBeRemoved;\n    bool cannotIncreaseDiscountPercent;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721TiersHookFlags.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member noNewTiersWithReserves A boolean indicating whether attempts to add new tiers with a non-zero\n/// `reserveFrequency` will revert.\n/// @custom:member noNewTiersWithVotes A boolean indicating whether attempts to add new tiers with non-zero\n/// `votingUnits` will revert.\n/// @custom:member noNewTiersWithOwnerMinting A boolean indicating whether attempts to add new tiers with\n/// `allowOwnerMint` set to true will revert.\n/// @custom:member preventOverspending A boolean indicating whether payments attempting to spend more than the price of\n/// the NFTs being minted will revert.\nstruct JB721TiersHookFlags {\n    bool noNewTiersWithReserves;\n    bool noNewTiersWithVotes;\n    bool noNewTiersWithOwnerMinting;\n    bool preventOverspending;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721TiersMintReservesConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member tierId The ID of the tier to mint from.\n/// @custom:member count The number of NFTs to mint from that tier.\nstruct JB721TiersMintReservesConfig {\n    uint32 tierId;\n    uint16 count;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721TiersSetDiscountPercentConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member tierId The ID of the tier to set the discount percent for.\n/// @custom:member discountPercent The discount percent to set for the tier.\nstruct JB721TiersSetDiscountPercentConfig {\n    uint32 tierId;\n    uint16 discountPercent;\n}\n"
			},
			"node_modules/@bananapus/core/src/abstract/JBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBPermissioned} from \"./../interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./../interfaces/IJBPermissions.sol\";\n\n/// @notice Modifiers to allow access to transactions based on which permissions the message's sender has.\nabstract contract JBPermissioned is Context, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n\n    error JBPermissioned_Unauthorized(address account, address sender, uint256 projectId, uint256 permissionId);\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    constructor(IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Require the message sender to be the account or have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view {\n        address sender = _msgSender();\n        if (\n            sender != account\n                && !PERMISSIONS.hasPermission({\n                    operator: sender,\n                    account: account,\n                    projectId: projectId,\n                    permissionId: permissionId,\n                    includeRoot: true,\n                    includeWildcardProjectId: true\n                })\n        ) revert JBPermissioned_Unauthorized(account, sender, projectId, permissionId);\n    }\n\n    /// @notice If the 'alsoGrantAccessIf' condition is truthy, proceed. Otherwise, require the message sender to be the\n    /// account or\n    /// have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n    {\n        if (alsoGrantAccessIf) return;\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/enums/JBApprovalStatus.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBController.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./IJBFundAccessLimits.sol\";\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./../structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./../structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {JBTerminalConfig} from \"./../structs/JBTerminalConfig.sol\";\n\ninterface IJBController is IERC165, IJBProjectUriRegistry, IJBDirectoryAccessControl {\n    event BurnTokens(\n        address indexed holder, uint256 indexed projectId, uint256 tokenCount, string memo, address caller\n    );\n    event LaunchProject(uint256 rulesetId, uint256 projectId, string projectUri, string memo, address caller);\n    event LaunchRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event MintTokens(\n        address indexed beneficiary,\n        uint256 indexed projectId,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        uint256 reservedPercent,\n        address caller\n    );\n    event PrepMigration(uint256 indexed projectId, address from, address caller);\n    event QueueRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event ReservedDistributionReverted(\n        uint256 indexed projectId, JBSplit split, uint256 tokenCount, bytes reason, address caller\n    );\n    event SendReservedTokensToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed groupId,\n        JBSplit split,\n        uint256 tokenCount,\n        address caller\n    );\n    event SendReservedTokensToSplits(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address owner,\n        uint256 tokenCount,\n        uint256 leftoverAmount,\n        address caller\n    );\n    event SetUri(uint256 indexed projectId, string uri, address caller);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n    function FUND_ACCESS_LIMITS() external view returns (IJBFundAccessLimits);\n    function PRICES() external view returns (IJBPrices);\n    function PROJECTS() external view returns (IJBProjects);\n    function RULESETS() external view returns (IJBRulesets);\n    function SPLITS() external view returns (IJBSplits);\n    function TOKENS() external view returns (IJBTokens);\n\n    function allRulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRulesetWithMetadata[] memory rulesets);\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory, JBRulesetMetadata memory metadata, JBApprovalStatus);\n    function pendingReservedTokenBalanceOf(uint256 projectId) external view returns (uint256);\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view returns (uint256);\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function addPriceFeed(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n    function burnTokensOf(address holder, uint256 projectId, uint256 tokenCount, string calldata memo) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 tokenCount, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 projectId);\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedPercent\n    )\n        external\n        returns (uint256 beneficiaryTokenCount);\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function sendReservedTokensToSplitsOf(uint256 projectId) external returns (uint256);\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] calldata splitGroups) external;\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 creditCount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBDirectory {\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed isAllowed, address caller);\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectoryAccessControl.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBDirectoryAccessControl {\n    function setControllerAllowed(uint256 projectId) external view returns (bool);\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBFundAccessLimits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./../structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"./../structs/JBFundAccessLimitGroup.sol\";\n\ninterface IJBFundAccessLimits {\n    event SetFundAccessLimits(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        JBFundAccessLimitGroup fundAccessLimitGroup,\n        address caller\n    );\n\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 payoutLimit);\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory payoutLimits);\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 surplusAllowance);\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory surplusAllowances);\n\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] memory fundAccessLimitGroups\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPayHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"./IJBPermissions.sol\";\n\ninterface IJBPermissioned {\n    function PERMISSIONS() external view returns (IJBPermissions);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPermissionsData} from \"./../structs/JBPermissionsData.sol\";\n\ninterface IJBPermissions {\n    event OperatorPermissionsSet(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed projectId,\n        uint8[] permissionIds,\n        uint256 packed,\n        address caller\n    );\n\n    function WILDCARD_PROJECT_ID() external view returns (uint256);\n\n    function permissionsOf(address operator, address account, uint256 projectId) external view returns (uint256);\n\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPriceFeed.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBPriceFeed {\n    function currentUnitPrice(uint256 targetDecimals) external view returns (uint256);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPrices.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBPrices {\n    event AddPriceFeed(\n        uint256 indexed projectId,\n        uint256 indexed pricingCurrency,\n        uint256 indexed unitCurrency,\n        IJBPriceFeed feed,\n        address caller\n    );\n\n    function DEFAULT_PROJECT_ID() external view returns (uint256);\n    function PROJECTS() external view returns (IJBProjects);\n\n    function priceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency\n    )\n        external\n        view\n        returns (IJBPriceFeed);\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        external\n        view\n        returns (uint256);\n\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjectUriRegistry.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBProjectUriRegistry {\n    function uriOf(uint256 projectId) external view returns (string memory);\n    function setUriOf(uint256 projectId, string calldata uri) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n    function setTokenUriResolver(IJBTokenUriResolver resolver) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\n/// @notice `IJBRulesetApprovalHook`s are used to determine whether the next ruleset in the ruleset queue is approved or\n/// rejected.\n/// @dev Project rulesets are stored in a queue. Rulesets take effect after the previous ruleset in the queue ends, and\n/// only if they are approved by the previous ruleset's approval hook.\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 start\n    )\n        external\n        view\n        returns (JBApprovalStatus);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesets.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets {\n    event RulesetInitialized(\n        uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId, address caller\n    );\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    event WeightCacheUpdated(uint256 projectId, uint112 weight, uint256 weightCutMultiple, address caller);\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n    function deriveCycleNumberFrom(\n        uint256 baseRulesetCycleNumber,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 start\n    )\n        external\n        returns (uint256);\n    function deriveStartFrom(\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        view\n        returns (uint256 start);\n    function deriveWeightFrom(\n        uint256 projectId,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 baseRulesetWeight,\n        uint256 baseRulesetWeightCutPercent,\n        uint256 baseRulesetCacheId,\n        uint256 start\n    )\n        external\n        view\n        returns (uint256 weight);\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n    function allOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n    function upcomingOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplitHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBSplitHookContext} from \"../structs/JBSplitHookContext.sol\";\n\n/// @title Split hook\n/// @notice Allows processing a single split with custom logic.\n/// @dev The split hook's address should be set as the `hook` in the relevant split.\ninterface IJBSplitHook is IERC165 {\n    /// @notice If a split has a split hook, payment terminals and controllers call this function while processing the\n    /// split.\n    /// @dev Critical business logic should be protected by appropriate access control. The tokens and/or native tokens\n    /// are optimistically transferred to the split hook when this function is called.\n    /// @param context The context passed by the terminal/controller to the split hook as a `JBSplitHookContext` struct:\n    function processSplitWith(JBSplitHookContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\n\ninterface IJBSplits {\n    event SetSplit(\n        uint256 indexed projectId, uint256 indexed rulesetId, uint256 indexed groupId, JBSplit split, address caller\n    );\n\n    function FALLBACK_RULESET_ID() external view returns (uint256);\n\n    function splitsOf(uint256 projectId, uint256 rulesetId, uint256 groupId) external view returns (JBSplit[] memory);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] memory splitGroups) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBPayHook} from \"./IJBPayHook.sol\";\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 returnedFees, string memo, bytes metadata, address caller\n    );\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 newlyIssuedTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n    event SetAccountingContext(uint256 indexed projectId, JBAccountingContext context, address caller);\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n    function currentSurplusOf(\n        uint256 projectId,\n        JBAccountingContext[] memory accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function addAccountingContextsFor(uint256 projectId, JBAccountingContext[] calldata accountingContexts) external;\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBToken.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBToken {\n    function balanceOf(address account) external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n\n    function initialize(string memory name, string memory symbol, address owner) external;\n    function burn(address account, uint256 amount) external;\n    function mint(address account, uint256 amount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokens.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBToken} from \"./IJBToken.sol\";\n\ninterface IJBTokens {\n    event DeployERC20(\n        uint256 indexed projectId, IJBToken indexed token, string name, string symbol, bytes32 salt, address caller\n    );\n    event Burn(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 count,\n        uint256 creditBalance,\n        uint256 tokenBalance,\n        address caller\n    );\n    event ClaimTokens(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 creditBalance,\n        uint256 count,\n        address beneficiary,\n        address caller\n    );\n    event Mint(\n        address indexed holder, uint256 indexed projectId, uint256 count, bool shouldClaimTokens, address caller\n    );\n    event SetToken(uint256 indexed projectId, IJBToken indexed token, address caller);\n    event TransferCredits(\n        address indexed holder, uint256 indexed projectId, address indexed recipient, uint256 count, address caller\n    );\n\n    function creditBalanceOf(address holder, uint256 projectId) external view returns (uint256);\n    function projectIdOf(IJBToken token) external view returns (uint256);\n    function tokenOf(uint256 projectId) external view returns (IJBToken);\n    function totalCreditSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalBalanceOf(address holder, uint256 projectId) external view returns (uint256 result);\n    function totalSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function burnFrom(address holder, uint256 projectId, uint256 count) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 count, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function mintFor(address holder, uint256 projectId, uint256 count) external;\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 count) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBConstants.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary JBConstants {\n    /// @notice Each chain's native token address in Juicebox is represented by\n    /// 0x000000000000000000000000000000000000EEEe.\n    address public constant NATIVE_TOKEN = address(0x000000000000000000000000000000000000EEEe);\n    uint16 public constant MAX_RESERVED_PERCENT = 10_000;\n    uint16 public constant MAX_CASH_OUT_TAX_RATE = 10_000;\n    uint32 public constant MAX_WEIGHT_CUT_PERCENT = 1_000_000_000;\n    uint32 public constant SPLITS_TOTAL_PERCENT = 1_000_000_000;\n    uint16 public constant MAX_FEE = 1000;\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBMetadataResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice Library to parse and create metadata to store {id: data} entries.\n *\n * @dev    Metadata are built as:\n *         - 32B of reserved space for the protocol\n *         - a lookup table `Id: offset`, defining the offset of the data for a given 4 bytes id.\n *           The offset fits 1 bytes, the ID 4 bytes. This table is padded to 32B.\n *         - the data for each id, padded to 32B each\n *\n *            +-----------------------+ offset: 0\n *            | 32B reserved          |\n *            +-----------------------+ offset: 1 = end of first 32B\n *            |      (ID1,offset1)    |\n *            |      (ID2,offset2)    |\n *            |       0's padding     |\n *            +-----------------------+ offset: offset1 = 1 + number of words taken by the padded table\n *            |       id1 data1       |\n *            | 0's padding           |\n *            +-----------------------+ offset: offset2 = offset1 + number of words taken by the data1\n *            |       id2 data2       |\n *            | 0's padding           |\n *            +-----------------------+\n */\nlibrary JBMetadataResolver {\n    error JBMetadataResolver_DataNotPadded();\n    error JBMetadataResolver_LengthMismatch();\n    error JBMetadataResolver_MetadataTooLong();\n    error JBMetadataResolver_MetadataTooShort();\n\n    // The various sizes used in bytes.\n    uint256 constant ID_SIZE = 4;\n    uint256 constant ID_OFFSET_SIZE = 1;\n    uint256 constant WORD_SIZE = 32;\n\n    // The size that an ID takes in the lookup table (Identifier + Offset).\n    uint256 constant TOTAL_ID_SIZE = 5; // ID_SIZE + ID_OFFSET_SIZE;\n\n    // The amount of bytes to go forward to get to the offset of the next ID (aka. the end of the offset of the current\n    // ID).\n    uint256 constant NEXT_ID_OFFSET = 9; // TOTAL_ID_SIZE + ID_SIZE;\n\n    // 1 word (32B) is reserved for the protocol .\n    uint256 constant RESERVED_SIZE = 32; // 1 * WORD_SIZE;\n    uint256 constant MIN_METADATA_LENGTH = 37; // RESERVED_SIZE + ID_SIZE + ID_OFFSET_SIZE;\n\n    /// @notice Add an {id: data} entry to an existing metadata. This is an append-only mechanism.\n    /// @param originalMetadata The original metadata\n    /// @param idToAdd The id to add\n    /// @param dataToAdd The data to add\n    /// @return newMetadata The new metadata with the entry added\n    function addToMetadata(\n        bytes memory originalMetadata,\n        bytes4 idToAdd,\n        bytes memory dataToAdd\n    )\n        internal\n        pure\n        returns (bytes memory newMetadata)\n    {\n        // Empty original metadata and maybe something in the first 32 bytes: create new metadata\n        if (originalMetadata.length <= RESERVED_SIZE) {\n            return abi.encodePacked(bytes32(originalMetadata), bytes32(abi.encodePacked(idToAdd, uint8(2))), dataToAdd);\n        }\n\n        // There is something in the table offset, but not a valid entry - avoid overwriting\n        if (originalMetadata.length < RESERVED_SIZE + ID_SIZE + 1) revert JBMetadataResolver_MetadataTooShort();\n\n        // Make sure the data is padded to 32 bytes.\n        if (dataToAdd.length < 32) revert JBMetadataResolver_DataNotPadded();\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)...\n        uint256 firstOffset = uint8(originalMetadata[RESERVED_SIZE + ID_SIZE]);\n\n        // ...go back to the beginning of the previous word (ie the last word of the table, as it can be padded)\n        uint256 lastWordOfTable = firstOffset - 1;\n\n        // The last offset stored in the table and its index\n        uint256 lastOffset;\n\n        // The number of words taken by the last data stored\n        uint256 numberOfWordslastData;\n\n        // Iterate to find the last entry of the table, lastOffset - we start from the end as the first value\n        // encountered\n        // will be the last offset\n        for (uint256 i = firstOffset * WORD_SIZE - 1; i > lastWordOfTable * WORD_SIZE - 1; i--) {\n            // If the byte is not 0, this is the last offset we're looking for\n            if (originalMetadata[i] != 0) {\n                lastOffset = uint8(originalMetadata[i]);\n                uint256 lastOffsetIndex = i;\n\n                // No rounding as this should be padded to 32B\n                numberOfWordslastData = (originalMetadata.length - lastOffset * WORD_SIZE) / WORD_SIZE;\n\n                // Copy the reserved word and the table and remove the previous padding\n                newMetadata = _sliceBytes(originalMetadata, 0, lastOffsetIndex + 1);\n\n                // Check if the new entry is still fitting in this word\n                if (i + TOTAL_ID_SIZE >= firstOffset * WORD_SIZE) {\n                    // Increment every offset by 1 (as the table now takes one more word)\n                    for (uint256 j = RESERVED_SIZE + ID_SIZE; j < lastOffsetIndex + 1; j += TOTAL_ID_SIZE) {\n                        newMetadata[j] = bytes1(uint8(originalMetadata[j]) + 1);\n                    }\n\n                    // Increment the last offset so the new offset will be properly set too\n                    lastOffset++;\n                }\n\n                break;\n            }\n        }\n\n        // Add the new entry after the last entry of the table, the new offset is the last offset + the number of words\n        // taken by the last data\n        newMetadata = abi.encodePacked(newMetadata, idToAdd, bytes1(uint8(lastOffset + numberOfWordslastData)));\n\n        // Pad as needed - inlined for gas saving\n        uint256 paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Add existing data at the end\n        newMetadata = abi.encodePacked(\n            newMetadata, _sliceBytes(originalMetadata, firstOffset * WORD_SIZE, originalMetadata.length)\n        );\n\n        // Pad as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Append new data at the end\n        newMetadata = abi.encodePacked(newMetadata, dataToAdd);\n\n        // Pad again again as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n    }\n\n    /// @notice Create the metadata for a list of {id:data}\n    /// @dev Intended for offchain use (gas heavy)\n    /// @param ids The list of ids\n    /// @param datas The list of corresponding datas\n    /// @return metadata The resulting metadata\n    function createMetadata(bytes4[] memory ids, bytes[] memory datas) internal pure returns (bytes memory metadata) {\n        if (ids.length != datas.length) revert JBMetadataResolver_LengthMismatch();\n\n        // Add a first empty 32B for the protocol reserved word\n        metadata = abi.encodePacked(bytes32(0));\n\n        // First offset for the data is after the first reserved word...\n        uint256 offset = 1;\n\n        // ... and after the id/offset lookup table, rounding up to 32 bytes words if not a multiple\n        offset += ((ids.length * JBMetadataResolver.TOTAL_ID_SIZE) - 1) / JBMetadataResolver.WORD_SIZE + 1;\n\n        // Keep a reference to the number of ids.\n        uint256 numberOfIds = ids.length;\n\n        // For each id, add it to the lookup table with the next free offset, then increment the offset by the data\n        // length (rounded up)\n        for (uint256 i; i < numberOfIds; ++i) {\n            // Set the data being iterated on.\n            bytes memory data = datas[i];\n\n            if (data.length < 32 || data.length % JBMetadataResolver.WORD_SIZE != 0) {\n                revert JBMetadataResolver_DataNotPadded();\n            }\n\n            metadata = abi.encodePacked(metadata, ids[i], bytes1(uint8(offset)));\n            offset += data.length / JBMetadataResolver.WORD_SIZE;\n\n            // Overflowing a bytes1?\n            if (offset > 255) revert JBMetadataResolver_MetadataTooLong();\n        }\n\n        // Pad the table to a multiple of 32B\n        uint256 paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n            ? metadata.length\n            : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n        assembly {\n            mstore(metadata, paddedLength)\n        }\n\n        // Keep a reference to the number of datas.\n        uint256 numberOfDatas = datas.length;\n\n        // Add each metadata to the array, each padded to 32 bytes\n        for (uint256 i; i < numberOfDatas; i++) {\n            metadata = abi.encodePacked(metadata, datas[i]);\n            paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n                ? metadata.length\n                : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n\n            assembly {\n                mstore(metadata, paddedLength)\n            }\n        }\n    }\n\n    /// @notice Parse the metadata to find the data for a specific ID\n    /// @dev Returns false and an empty bytes if no data is found\n    /// @param id The ID to find.\n    /// @param metadata The metadata to parse.\n    /// @return found Whether the {id:data} was found\n    /// @return targetData The data for the ID (can be empty)\n    function getDataFor(bytes4 id, bytes memory metadata) internal pure returns (bool found, bytes memory targetData) {\n        // Either no data or empty one with only one selector (32+4+1)\n        if (metadata.length <= MIN_METADATA_LENGTH) return (false, \"\");\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)\n        uint256 firstOffset = uint8(metadata[RESERVED_SIZE + ID_SIZE]);\n\n        // Parse the id's to find id, stop when next offset == 0 or current = first offset\n        for (uint256 i = RESERVED_SIZE; metadata[i + ID_SIZE] != bytes1(0) && i < firstOffset * WORD_SIZE;) {\n            // Set the current offset.\n            uint256 currentOffset = uint256(uint8(metadata[i + ID_SIZE]));\n\n            bytes4 parsedId;\n            assembly {\n                parsedId := mload(add(add(metadata, 0x20), i))\n            }\n\n            // _id found?\n            if (parsedId == id) {\n                // Are we at the end of the lookup table (either at the start of data's or next offset is 0/in the\n                // padding)\n                // If not, only return until from this offset to the begining of the next offset\n                uint256 end = (i + NEXT_ID_OFFSET >= firstOffset * WORD_SIZE || metadata[i + NEXT_ID_OFFSET] == 0)\n                    ? metadata.length\n                    : uint256(uint8(metadata[i + NEXT_ID_OFFSET])) * WORD_SIZE;\n\n                return (true, _sliceBytes(metadata, currentOffset * WORD_SIZE, end));\n            }\n            unchecked {\n                i += TOTAL_ID_SIZE;\n            }\n        }\n    }\n\n    /// @notice Returns an unique id following a suggested format (`xor(address(this), purpose name)` where purpose name\n    /// is a string giving context to the id (Permit2, quoteForSwap, etc)\n    /// @param purpose A string describing the purpose associated with the id\n    /// @return id The resulting ID.\n    function getId(string memory purpose) internal view returns (bytes4) {\n        return getId(purpose, address(this));\n    }\n\n    /// @notice Returns an unique id following a suggested format (`xor(address(this), purpose name)` where purpose name\n    /// is a string giving context to the id (Permit2, quoteForSwap, etc)\n    /// @param purpose A string describing the purpose associated with the id\n    /// @param target The target which will use the metadata\n    /// @return id The resulting ID.\n    function getId(string memory purpose, address target) internal pure returns (bytes4) {\n        return bytes4(bytes20(target) ^ bytes20(keccak256(bytes(purpose))));\n    }\n\n    /// @notice Slice bytes from a start index to an end index.\n    /// @param data The bytes array to slice\n    /// @param start The start index to slice at.\n    /// @param end The end index to slice at.\n    /// @param slicedBytes The sliced array.\n    function _sliceBytes(\n        bytes memory data,\n        uint256 start,\n        uint256 end\n    )\n        private\n        pure\n        returns (bytes memory slicedBytes)\n    {\n        assembly {\n            let length := sub(end, start)\n\n            // Allocate memory at the freemem(add 0x20 to include the length)\n            slicedBytes := mload(0x40)\n            mstore(0x40, add(add(slicedBytes, length), 0x20))\n\n            // Store the length (first element)\n            mstore(slicedBytes, length)\n\n            // compute the actual data first offset only once\n            let startBytes := add(add(data, 0x20), start)\n\n            // same for the out array\n            let sliceBytesStartOfData := add(slicedBytes, 0x20)\n\n            // store dem data\n            for { let i := 0 } lt(i, end) { i := add(i, 0x20) } {\n                mstore(add(sliceBytesStartOfData, i), mload(add(startBytes, i)))\n            }\n        }\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAccountingContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAfterPayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member newlyIssuedTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 newlyIssuedTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBCurrencyAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The amount of the currency.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBCurrencyAmount {\n    uint224 amount;\n    uint32 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBFundAccessLimitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./JBCurrencyAmount.sol\";\n\n/// @dev Payout limit example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH, then\n/// the project can pay out 5 USD worth of ETH during a ruleset.\n/// @dev Surplus allowance example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH,\n/// then the project can pay out 5 USD worth of ETH from its surplus during a ruleset. A project's surplus is its\n/// balance minus its current combined payout limit.\n/// @dev If a project has multiple payout limits or surplus allowances, they are all available. They can all be used\n/// during a single ruleset.\n/// @dev The payout limits' and surplus allowances' fixed point amounts have the same number of decimals as the\n/// terminal.\n/// @custom:member terminal The terminal that the payout limits and surplus allowances apply to.\n/// @custom:member token The token that the payout limits and surplus allowances apply to within the `terminal`.\n/// @custom:member payoutLimits An array of payout limits. The payout limits cumulatively dictate the maximum value of\n/// `token`s a project can pay out from its balance in a terminal during a ruleset. Each payout limit can have a unique\n/// currency and amount.\n/// @custom:member surplusAllowances An array of surplus allowances. The surplus allowances cumulatively dictates the\n/// maximum value of `token`s a project can pay out from its surplus (balance less payouts) in a terminal during a\n/// ruleset. Each surplus allowance can have a unique currency and amount.\nstruct JBFundAccessLimitGroup {\n    address terminal;\n    address token;\n    JBCurrencyAmount[] payoutLimits;\n    JBCurrencyAmount[] surplusAllowances;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member operator The address that permissions are being given to.\n/// @custom:member projectId The ID of the project the operator is being given permissions for. Operators only have\n/// permissions under this project's scope. An ID of 0 is a wildcard, which gives an operator permissions across all\n/// projects.\n/// @custom:member permissionIds The IDs of the permissions being given. See the `JBPermissionIds` library.\nstruct JBPermissionsData {\n    address operator;\n    uint56 projectId;\n    uint8[] permissionIds;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRuleset.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `weightCutPercent`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member weightCutPercent The percentage by which to reduce the `weight` each time a new ruleset starts.\n/// `weight`\n/// is\n/// a percentage out of `JBConstants.MAX_WEIGHT_CUT_PERCENT`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `weightCutPercent` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint48 cycleNumber;\n    uint48 id;\n    uint48 basedOnId;\n    uint48 start;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"../interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"./JBFundAccessLimitGroup.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\nimport {JBSplitGroup} from \"./JBSplitGroup.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active – any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a cut `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member weightCutPercent A percent by how much the `weight` of the subsequent ruleset should be reduced, if\n/// the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_WEIGHT_CUT_PERCENT`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `_payoutLimit` and `_surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBRulesetConfig {\n    uint48 mustStartAtOrAfter;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    JBRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedPercent The reserved percent of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_PERCENT`.\n/// @custom:member cashOutTaxRate The cash out tax rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_CASH_OUT_TAX_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member allowAddAccountingContext A flag indicating if a project can add new accounting contexts for its\n/// terminals to use.\n/// @custom:member allowAddPriceFeed A flag indicating if a project can add new price feeds to calculate exchange rates\n/// between its tokens.\n/// @custom:member ownerMustSendPayouts A flag indicating if privileged payout distribution should be\n/// enforced, otherwise payouts can be distributed by anyone.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForCashOuts A flag indicating if cash outs should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the cash out is being fulfilled.\n/// @custom:member useDataHookForPay A flag indicating if the data hook should be used for pay transactions during this\n/// ruleset.\n/// @custom:member useDataHookForCashOut A flag indicating if the data hook should be used for cash out transactions\n/// during\n/// this ruleset.\n/// @custom:member dataHook The data hook to use during this ruleset.\n/// @custom:member metadata Metadata of the metadata, only the 14 least significant bits can be used, the 2 most\n/// significant bits are disregarded.\nstruct JBRulesetMetadata {\n    uint16 reservedPercent;\n    uint16 cashOutTaxRate;\n    uint32 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowSetCustomToken;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowSetController;\n    bool allowAddAccountingContext;\n    bool allowAddPriceFeed;\n    bool ownerMustSendPayouts;\n    bool holdFees;\n    bool useTotalSurplusForCashOuts;\n    bool useDataHookForPay;\n    bool useDataHookForCashOut;\n    address dataHook;\n    uint16 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetWithMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBRuleset} from \"./JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\n\n/// @custom:member ruleset The ruleset.\n/// @custom:member metadata The ruleset's metadata.\nstruct JBRulesetWithMetadata {\n    JBRuleset ruleset;\n    JBRulesetMetadata metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplit.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplitHook} from \"./../interfaces/IJBSplitHook.sol\";\n\n/// @notice Splits are used to send a percentage of a total token amount to a specific contract, project, or address.\n/// Splits are used to send payouts and reserved tokens.\n/// @dev 1. If a non-zero split hook contract is specified, this split's tokens are sent there along with this split's\n/// properties.\n/// @dev 2. Otherwise, if a non-zero project ID is specified, this split's tokens are used to `pay` it through its\n/// terminal if possible, or sent to the project's owner if not. If this payment yields tokens, those go to the split's\n/// `beneficiary`.\n/// @dev 3. Otherwise, this split's tokens are sent directly to the `beneficiary`.\n/// @dev To summarize, this split's tokens are sent according to the following priority: `split hook` > `projectId` >\n/// `beneficiary`.\n/// @custom:member preferAddToBalance If this split were to `pay` a project through its terminal, this flag indicates\n/// whether it should prefer using the terminal's `addToBalance` function instead.\n/// @custom:member percent The percent of the total token amount that this split sends. This number is out of\n/// `JBConstants.SPLITS_TOTAL_PERCENT`.\n/// @custom:member projectId The ID of a project to `pay`, if applicable. Resulting tokens will be routed to the\n/// `beneficiary`.\n/// @custom:member beneficiary Receives this split's tokens if the `hook` and `projectId` are zero. If the `projectId`\n/// is specified, the `beneficiary` receives any project tokens minted by this split.\n/// @custom:member lockedUntil The split cannot be changed until this timestamp. The `lockedUntil` timestamp can be\n/// increased while a split is locked. If `lockedUntil` is zero, this split can be changed at any time.\n/// @custom:member hook A contract which will receive this split's tokens and properties, and can define custom\n/// behavior.\nstruct JBSplit {\n    bool preferAddToBalance;\n    uint32 percent;\n    uint56 projectId;\n    address payable beneficiary;\n    uint48 lockedUntil;\n    IJBSplitHook hook;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member groupId An identifier for the group. By convention, this ID is `uint256(uint160(tokenAddress))` for\n/// payouts and `1` for reserved tokens.\n/// @custom:member splits The splits in the group.\nstruct JBSplitGroup {\n    uint256 groupId;\n    JBSplit[] splits;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitHookContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member token The token being sent to the split hook.\n/// @custom:member amount The amount being sent to the split hook, as a fixed point number.\n/// @custom:member decimals The number of decimals in the amount.\n/// @custom:member projectId The project the split belongs to.\n/// @custom:member groupId The group the split belongs to. By convention, this ID is `uint256(uint160(tokenAddress))`\n/// for payouts and `1` for reserved tokens.\n/// @custom:member split The split which specified the hook.\nstruct JBSplitHookContext {\n    address token;\n    uint256 amount;\n    uint256 decimals;\n    uint256 projectId;\n    uint256 groupId;\n    JBSplit split;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTerminalConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAccountingContext} from \"./JBAccountingContext.sol\";\nimport {IJBTerminal} from \"./../interfaces/IJBTerminal.sol\";\n\n/// @custom:member terminal The terminal to configure.\n/// @custom:member accountingContextsToAccept The accounting contexts to accept from the terminal.\nstruct JBTerminalConfig {\n    IJBTerminal terminal;\n    JBAccountingContext[] accountingContextsToAccept;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTokenAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\nstruct JBTokenAmount {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n    uint256 value;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\n\nimport {JBOwnableOverrides} from \"./JBOwnableOverrides.sol\";\n\ncontract JBOwnable is JBOwnableOverrides {\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param initialProjectIdOwner The initial project id that owns this contract.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        address initialOwner,\n        uint88 initialProjectIdOwner\n    )\n        JBOwnableOverrides(permissions, projects, initialOwner, initialProjectIdOwner)\n    {}\n\n    //*********************************************************************//\n    // --------------------------- modifiers ----------------------------- //\n    //*********************************************************************//\n\n    /// @notice Reverts if called by an address that is not the owner and does not have permission from the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Either `newOwner` or `newProjectId` is non-zero or both are zero. But they can never both be non-zero.\n    /// @dev This function exists because some contracts will try to deploy contracts for a project before\n    function _emitTransferEvent(\n        address previousOwner,\n        address newOwner,\n        uint88 newProjectId\n    )\n        internal\n        virtual\n        override\n    {\n        emit OwnershipTransferred({\n            previousOwner: previousOwner,\n            newOwner: newProjectId == 0 ? newOwner : PROJECTS.ownerOf(newProjectId),\n            caller: msg.sender\n        });\n    }\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnableOverrides.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBOwnable} from \"./interfaces/IJBOwnable.sol\";\nimport {JBOwner} from \"./struct/JBOwner.sol\";\n\n/// @notice Access control module to grant exclusive access to a specified address (the owner) for specific functions.\n/// The owner can also grant access permissions to other addresses via `JBPermissions`.\n/// @dev Inherit this contract to make the `onlyOwner` modifier available. When applied to a function, this modifier\n/// restricts use to the owner and addresses with the appropriate permission from the owner.\nabstract contract JBOwnableOverrides is Context, JBPermissioned, IJBOwnable {\n    //*********************************************************************//\n    // --------------------------- custom errors --------------------------//\n    //*********************************************************************//b\n\n    error JBOwnableOverrides_InvalidNewOwner();\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice This contract's owner information.\n    JBOwner public override jbOwner;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param initialProjectIdOwner The initial project id that owns this contract.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        address initialOwner,\n        uint88 initialProjectIdOwner\n    )\n        JBPermissioned(permissions)\n    {\n        PROJECTS = projects;\n\n        // We force the inheriting contract to set an owner, as there is a\n        // low chance someone will use `JBOwnable` to create an unowned contract.\n        // But a higher chance that both are accidentally set to be `0`.\n        // If you really want an unowned contract, set the owner to any address then renounce in the constructor body.\n        if (initialProjectIdOwner == 0 && initialOwner == address(0)) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n\n        _transferOwnership(initialOwner, initialProjectIdOwner);\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns the owner's address based on this contract's `JBOwner` owner information.\n    /// @return owner The owner's address.\n    function owner() public view virtual returns (address) {\n        JBOwner memory ownerInfo = jbOwner;\n\n        if (ownerInfo.projectId == 0) {\n            return ownerInfo.owner;\n        }\n\n        return PROJECTS.ownerOf(ownerInfo.projectId);\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Reverts if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        JBOwner memory ownerInfo = jbOwner;\n\n        _requirePermissionFrom({\n            account: ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId),\n            projectId: ownerInfo.projectId,\n            permissionId: ownerInfo.permissionId\n        });\n    }\n\n    //*********************************************************************//\n    // ---------------------- public transactions ------------------------ //\n    //*********************************************************************//\n\n    /// @notice Gives up ownership of this contract, making it impossible to call `onlyOwner`/`_checkOwner` functions.\n    /// Can only be called by the current owner.\n    function renounceOwnership() public virtual override {\n        _checkOwner();\n        _transferOwnership(address(0), 0);\n    }\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function setPermissionId(uint8 permissionId) public virtual override {\n        _checkOwner();\n        _setPermissionId(permissionId);\n    }\n\n    /// @notice Transfers ownership of this contract to a new account (the `newOwner`). Can only be called by the\n    /// current owner.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function transferOwnership(address newOwner) public virtual override {\n        _checkOwner();\n        if (newOwner == address(0)) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfer ownership of this contract to a new Juicebox project.\n    /// @dev The `projectId` must fit within a `uint88`.\n    /// @param projectId The ID of the project that should receive ownership of this contract.\n    function transferOwnershipToProject(uint256 projectId) public virtual override {\n        _checkOwner();\n        if (projectId == 0 || projectId > type(uint88).max) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n\n        _transferOwnership(address(0), uint88(projectId));\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Either `newOwner` or `newProjectId` is non-zero or both are zero. But they can never both be non-zero.\n    /// @dev This function exists because some contracts will try to deploy contracts for a project before\n    function _emitTransferEvent(address previousOwner, address newOwner, uint88 newProjectId) internal virtual;\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @dev Internal function without access restriction.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function _setPermissionId(uint8 permissionId) internal virtual {\n        jbOwner.permissionId = permissionId;\n        emit PermissionIdChanged({newId: permissionId, caller: msg.sender});\n    }\n\n    /// @notice Helper to allow for drop-in replacement of OpenZeppelin.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function _transferOwnership(address newOwner) internal virtual {\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfers this contract's ownership to an address (`newOwner`) OR a Juicebox project (`projectId`).\n    /// @dev Updates this contract's `JBOwner` owner information.\n    /// @dev If both `newOwner` and `projectId` are set, this will revert.\n    /// @dev Internal function without access restriction.\n    /// @param newOwner The address that should receive ownership of this contract.\n    /// @param projectId The ID of the project that this contract should respect the ownership of.\n    function _transferOwnership(address newOwner, uint88 projectId) internal virtual {\n        // Can't set both a new owner and a new project ID.\n        if (projectId != 0 && newOwner != address(0)) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n        // Load the owner information from storage.\n        JBOwner memory ownerInfo = jbOwner;\n        // Get the address of the old owner.\n        address oldOwner = ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId);\n        // Update the stored owner information to the new owner and reset the `permissionId`.\n        // This is to prevent permissions clashes for the new user/owner.\n        jbOwner = JBOwner({owner: newOwner, projectId: projectId, permissionId: 0});\n        // Emit a transfer event with the new owner's address.\n        _emitTransferEvent(oldOwner, newOwner, projectId);\n    }\n}\n"
			},
			"node_modules/@bananapus/ownable/src/interfaces/IJBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\n\ninterface IJBOwnable {\n    event PermissionIdChanged(uint8 newId, address caller);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n    function jbOwner() external view returns (address owner, uint88 projectOwner, uint8 permissionId);\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n    function setPermissionId(uint8 permissionId) external;\n    function transferOwnership(address newOwner) external;\n    function transferOwnershipToProject(uint256 projectId) external;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/struct/JBOwner.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Owner information for a given instance of `JBOwnableOverrides`.\n/// @custom:member owner If `projectId` is 0 and this is set, this static address has owner access.\n/// @custom:member projectId Unless this is 0, this project's owner has owner access.\n/// @custom:member permissionId The ID of the permission required from the project's owner to have owner access. See\n/// `JBPermissions` in `juice-contracts-v4`.\nstruct JBOwner {\n    address owner;\n    uint88 projectId;\n    uint8 permissionId;\n}\n"
			},
			"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Permission IDs for `JBPermissions`, used throughout the Bananapus ecosystem. See\n/// [`JBPermissions`](https://github.com/Bananapus/nana-core/blob/main/src/JBPermissions.sol)\n/// @dev `JBPermissions` allows one address to grant another address permission to call functions in Juicebox contracts\n/// on their behalf. Each ID in `JBPermissionIds` grants access to a specific set of these functions.\nlibrary JBPermissionIds {\n    uint8 internal constant ROOT = 1; // All permissions across every contract. Very dangerous. BE CAREFUL!\n\n    /* Used by `nana-core`: https://github.com/Bananapus/nana-core */\n    uint8 internal constant QUEUE_RULESETS = 2; // Permission to call `JBController.queueRulesetsOf` and\n        // `JBController.launchRulesetsFor`.\n    uint8 internal constant CASH_OUT_TOKENS = 3; // Permission to call `JBMultiTerminal.cashOutTokensOf`.\n    uint8 internal constant SEND_PAYOUTS = 4; // Permission to call `JBMultiTerminal.sendPayoutsOf`.\n    uint8 internal constant MIGRATE_TERMINAL = 5; // Permission to call `JBMultiTerminal.migrateBalanceOf`.\n    uint8 internal constant SET_PROJECT_URI = 6; // Permission to call `JBController.setUriOf`.\n    uint8 internal constant DEPLOY_ERC20 = 7; // Permission to call `JBController.deployERC20For`.\n    uint8 internal constant SET_TOKEN = 8; // Permission to call `JBController.setTokenFor`.\n    uint8 internal constant MINT_TOKENS = 9; // Permission to call `JBController.mintTokensOf`.\n    uint8 internal constant BURN_TOKENS = 10; // Permission to call `JBController.burnTokensOf`.\n    uint8 internal constant CLAIM_TOKENS = 11; // Permission to call `JBController.claimTokensFor`.\n    uint8 internal constant TRANSFER_CREDITS = 12; // Permission to call `JBController.transferCreditsFrom`.\n    uint8 internal constant SET_CONTROLLER = 13; // Permission to call `JBDirectory.setControllerOf`.\n    uint8 internal constant SET_TERMINALS = 14; // Permission to call `JBDirectory.setTerminalsOf`.\n    // Be careful - `SET_TERMINALS` can be used to remove the primary terminal.\n    uint8 internal constant SET_PRIMARY_TERMINAL = 15; // Permission to call `JBDirectory.setPrimaryTerminalOf`.\n    uint8 internal constant USE_ALLOWANCE = 16; // Permission to call `JBMultiTerminal.useAllowanceOf`.\n    uint8 internal constant SET_SPLIT_GROUPS = 17; // Permission to call `JBController.setSplitGroupsOf`.\n    uint8 internal constant ADD_PRICE_FEED = 18; // Permission to call `JBPrices.addPriceFeedFor`.\n    uint8 internal constant ADD_ACCOUNTING_CONTEXTS = 19; // Permission to call\n        // `JBMultiTerminal.addAccountingContextsFor`.\n\n    /* Used by `nana-721-hook`: https://github.com/Bananapus/nana-721-hook */\n    uint8 internal constant ADJUST_721_TIERS = 20; // Permission to call `JB721TiersHook.adjustTiers`.\n    uint8 internal constant SET_721_METADATA = 21; // Permission to call `JB721TiersHook.setMetadata`.\n    uint8 internal constant MINT_721 = 22; // Permission to call `JB721TiersHook.mintFor`.\n    uint8 internal constant SET_721_DISCOUNT_PERCENT = 23; // Permission to call `JB721TiersHook.setDiscountPercentOf`.\n\n    /* Used by `nana-buyback-hook`: https://github.com/Bananapus/nana-buyback-hook */\n    uint8 internal constant SET_BUYBACK_TWAP = 24; // Permission to call `JBBuybackHook.setTwapWindowOf` and\n        // `JBBuybackHook.setTwapSlippageToleranceOf`.\n    uint8 internal constant SET_BUYBACK_POOL = 25; // Permission to call `JBBuybackHook.setPoolFor`.\n\n    /* Used by `nana-swap-terminal`: https://github.com/Bananapus/nana-swap-terminal */\n    uint8 internal constant ADD_SWAP_TERMINAL_POOL = 26; // Permission to call `JBSwapTerminal.addDefaultPool`.\n    uint8 internal constant ADD_SWAP_TERMINAL_TWAP_PARAMS = 27; // Permission to call\n        // `JBSwapTerminal.addTwapParamsFor`.\n\n    /* Used by `nana-suckers`: https://github.com/Bananapus/nana-suckers */\n    uint8 internal constant MAP_SUCKER_TOKEN = 28; // Permission to call `BPSucker.mapToken`.\n    uint8 internal constant DEPLOY_SUCKERS = 29; // Permission to call `BPSuckerRegistry.deploySuckersFor`.\n    uint8 internal constant SUCKER_SAFETY = 30; // Permission to call `BPSucker.enableEmergencyHatchFor` and\n        // `BPSucker.setDeprecation`.\n}\n"
			},
			"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC-2771 support.\n *\n * WARNING: Avoid using this pattern in contracts that rely in a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC-2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[:calldataLength - contextSuffixLength];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
			},
			"src/CTPublisher.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {JB721Tier} from \"@bananapus/721-hook/src/structs/JB721Tier.sol\";\nimport {JB721TierConfig} from \"@bananapus/721-hook/src/structs/JB721TierConfig.sol\";\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBTerminal} from \"@bananapus/core/src/interfaces/IJBTerminal.sol\";\nimport {JBConstants} from \"@bananapus/core/src/libraries/JBConstants.sol\";\nimport {JBMetadataResolver} from \"@bananapus/core/src/libraries/JBMetadataResolver.sol\";\nimport {JBOwnable} from \"@bananapus/ownable/src/JBOwnable.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {ICTPublisher} from \"./interfaces/ICTPublisher.sol\";\nimport {CTAllowedPost} from \"./structs/CTAllowedPost.sol\";\nimport {CTPost} from \"./structs/CTPost.sol\";\n\n/// @notice A contract that facilitates the permissioned publishing of NFT posts to a Juicebox project.\ncontract CTPublisher is JBPermissioned, ERC2771Context, ICTPublisher {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error CTPublisher_EmptyEncodedIPFSUri();\n    error CTPublisher_InsufficientEthSent(uint256 expected, uint256 sent);\n    error CTPublisher_MaxTotalSupplyLessThanMin(uint256 min, uint256 max);\n    error CTPublisher_NotInAllowList(address addr, address[] allowedAddresses);\n    error CTPublisher_PriceTooSmall(uint256 price, uint256 minimumPrice);\n    error CTPublisher_TotalSupplyTooBig(uint256 totalSupply, uint256 maximumTotalSupply);\n    error CTPublisher_TotalSupplyTooSmall(uint256 totalSupply, uint256 minimumTotalSupply);\n    error CTPublisher_UnauthorizedToPostInCategory();\n    error CTPublisher_ZeroTotalSupply();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @notice The divisor that describes the fee that should be taken.\n    /// @dev This is equal to 100 divided by the fee percent.\n    uint256 public constant override FEE_DIVISOR = 20;\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice The controller that directs the projects being posted to.\n    IJBController public immutable override CONTROLLER;\n\n    /// @notice The ID of the project to which fees will be routed.\n    uint256 public immutable override FEE_PROJECT_ID;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The ID of the tier that an IPFS metadata has been saved to.\n    /// @custom:param hook The hook for which the tier ID applies.\n    /// @custom:param encodedIPFSUri The IPFS URI.\n    mapping(address hook => mapping(bytes32 encodedIPFSUri => uint256)) public override tierIdForEncodedIPFSUriOf;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice Stores addresses that are allowed to post onto a hook category.\n    /// @custom:param hook The hook for which this allowance applies.\n    /// @custom:param category The category for which the allowance applies.\n    /// @custom:param address The address to check an allowance for.\n    mapping(address hook => mapping(uint256 category => address[])) internal _allowedAddresses;\n\n    /// @notice Packed values that determine the allowance of posts.\n    /// @custom:param hook The hook for which this allowance applies.\n    /// @custom:param category The category for which the allowance applies\n    mapping(address hook => mapping(uint256 category => uint256)) internal _packedAllowanceFor;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param controller The controller that directs the projects being posted to.\n    /// @param permissions A contract storing permissions.\n    /// @param feeProjectId The ID of the project to which fees will be routed.\n    /// @param trustedForwarder The trusted forwarder for the ERC2771Context.\n    constructor(\n        IJBController controller,\n        IJBPermissions permissions,\n        uint256 feeProjectId,\n        address trustedForwarder\n    )\n        JBPermissioned(permissions)\n        ERC2771Context(trustedForwarder)\n    {\n        CONTROLLER = controller;\n        FEE_PROJECT_ID = feeProjectId;\n    }\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Get the tiers for the provided encoded IPFS URIs.\n    /// @param hook The hook from which to get tiers.\n    /// @param encodedIPFSUris The URIs to get tiers of.\n    /// @return tiers The tiers that correspond to the provided encoded IPFS URIs. If there's no tier yet, an empty tier\n    /// is returned.\n    function tiersFor(\n        address hook,\n        bytes32[] memory encodedIPFSUris\n    )\n        external\n        view\n        override\n        returns (JB721Tier[] memory tiers)\n    {\n        uint256 numberOfEncodedIPFSUris = encodedIPFSUris.length;\n\n        // Initialize the tier array being returned.\n        tiers = new JB721Tier[](numberOfEncodedIPFSUris);\n\n        // Get the tier for each provided encoded IPFS URI.\n        for (uint256 i; i < numberOfEncodedIPFSUris; i++) {\n            // Check if there's a tier ID stored for the encoded IPFS URI.\n            uint256 tierId = tierIdForEncodedIPFSUriOf[hook][encodedIPFSUris[i]];\n\n            // If there's a tier ID stored, resolve it.\n            if (tierId != 0) {\n                // slither-disable-next-line calls-loop\n                tiers[i] = IJB721TiersHook(hook).STORE().tierOf(hook, tierId, false);\n            }\n        }\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Post allowances for a particular category on a particular hook.\n    /// @param hook The hook contract for which this allowance applies.\n    /// @param category The category for which this allowance applies.\n    /// @return minimumPrice The minimum price that a poster must pay to record a new NFT.\n    /// @return minimumTotalSupply The minimum total number of available tokens that a minter must set to record a new\n    /// NFT.\n    /// @return maximumTotalSupply The max total supply of NFTs that can be made available when minting. Leave as 0 for\n    /// max.\n    /// @return allowedAddresses The addresses allowed to post. Returns empty if all addresses are allowed.\n    function allowanceFor(\n        address hook,\n        uint256 category\n    )\n        public\n        view\n        override\n        returns (\n            uint256 minimumPrice,\n            uint256 minimumTotalSupply,\n            uint256 maximumTotalSupply,\n            address[] memory allowedAddresses\n        )\n    {\n        // Get a reference to the packed values.\n        uint256 packed = _packedAllowanceFor[hook][category];\n\n        // minimum price in bits 0-103 (104 bits).\n        minimumPrice = uint256(uint104(packed));\n        // minimum supply in bits 104-135 (32 bits).\n        minimumTotalSupply = uint256(uint32(packed >> 104));\n        // minimum supply in bits 136-67 (32 bits).\n        maximumTotalSupply = uint256(uint32(packed >> 136));\n\n        allowedAddresses = _allowedAddresses[hook][category];\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @dev ERC-2771 specifies the context as being a single address (20 bytes).\n    function _contextSuffixLength() internal view virtual override(ERC2771Context, Context) returns (uint256) {\n        return super._contextSuffixLength();\n    }\n\n    /// @notice Check if an address is included in an allow list.\n    /// @param addrs The candidate address.\n    /// @param addresses An array of allowed addresses.\n    function _isAllowed(address addrs, address[] memory addresses) internal pure returns (bool) {\n        // Keep a reference to the number of address to check against.\n        uint256 numberOfAddresses = addresses.length;\n\n        // Check if the address is included\n        for (uint256 i; i < numberOfAddresses; i++) {\n            if (addrs == addresses[i]) return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Returns the calldata, prefered to use over `msg.data`\n    /// @return calldata the `msg.data` of this call\n    function _msgData() internal view override(ERC2771Context, Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    /// @notice Returns the sender, prefered to use over `msg.sender`\n    /// @return sender the sender address of this call.\n    function _msgSender() internal view override(ERC2771Context, Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Collection owners can set the allowed criteria for publishing a new NFT to their project.\n    /// @param allowedPosts An array of criteria for allowed posts.\n    function configurePostingCriteriaFor(CTAllowedPost[] memory allowedPosts) external override {\n        // Keep a reference to the number of post criteria.\n        uint256 numberOfAllowedPosts = allowedPosts.length;\n\n        // For each post criteria, save the specifications.\n        for (uint256 i; i < numberOfAllowedPosts; i++) {\n            // Set the post criteria being iterated on.\n            CTAllowedPost memory allowedPost = allowedPosts[i];\n\n            emit ConfigurePostingCriteria({hook: allowedPost.hook, allowedPost: allowedPost, caller: _msgSender()});\n\n            // Enforce permissions.\n            // slither-disable-next-line reentrancy-events,calls-loop\n            _requirePermissionFrom({\n                account: JBOwnable(allowedPost.hook).owner(),\n                projectId: IJB721TiersHook(allowedPost.hook).PROJECT_ID(),\n                permissionId: JBPermissionIds.ADJUST_721_TIERS\n            });\n\n            // Make sure there is a minimum supply.\n            if (allowedPost.minimumTotalSupply == 0) {\n                revert CTPublisher_ZeroTotalSupply();\n            }\n\n            // Make sure the minimum supply does not surpass the maximum supply.\n            if (allowedPost.minimumTotalSupply > allowedPost.maximumTotalSupply) {\n                revert CTPublisher_MaxTotalSupplyLessThanMin(\n                    allowedPost.minimumTotalSupply, allowedPost.maximumTotalSupply\n                );\n            }\n\n            uint256 packed;\n            // minimum price in bits 0-103 (104 bits).\n            packed |= uint256(allowedPost.minimumPrice);\n            // minimum total supply in bits 104-135 (32 bits).\n            packed |= uint256(allowedPost.minimumTotalSupply) << 104;\n            // maximum total supply in bits 136-167 (32 bits).\n            packed |= uint256(allowedPost.maximumTotalSupply) << 136;\n            // Store the packed value.\n            _packedAllowanceFor[allowedPost.hook][allowedPost.category] = packed;\n\n            // Store the allow list.\n            uint256 numberOfAddresses = allowedPost.allowedAddresses.length;\n            // Reset the addresses.\n            delete _allowedAddresses[allowedPost.hook][allowedPost.category];\n            // Add the number allowed addresses.\n            if (numberOfAddresses != 0) {\n                // Keep a reference to the storage of the allowed addresses.\n                for (uint256 j = 0; j < numberOfAddresses; j++) {\n                    _allowedAddresses[allowedPost.hook][allowedPost.category].push(allowedPost.allowedAddresses[j]);\n                }\n            }\n        }\n    }\n\n    /// @notice Publish an NFT to become mintable, and mint a first copy.\n    /// @dev A fee is taken into the appropriate treasury.\n    /// @param hook The hook to mint from.\n    /// @param posts An array of posts that should be published as NFTs to the specified project.\n    /// @param nftBeneficiary The beneficiary of the NFT mints.\n    /// @param feeBeneficiary The beneficiary of the fee project's token.\n    /// @param additionalPayMetadata Metadata bytes that should be included in the pay function's metadata. This\n    /// prepends the\n    /// payload needed for NFT creation.\n    /// @param feeMetadata The metadata to send alongside the fee payment.\n    function mintFrom(\n        IJB721TiersHook hook,\n        CTPost[] calldata posts,\n        address nftBeneficiary,\n        address feeBeneficiary,\n        bytes calldata additionalPayMetadata,\n        bytes calldata feeMetadata\n    )\n        external\n        payable\n        override\n    {\n        // Keep a reference to the amount being paid, which is msg.value minus the fee.\n        uint256 payValue = msg.value;\n\n        // Keep a reference to the mint metadata.\n        bytes memory mintMetadata;\n\n        // Keep a reference to the project's ID.\n        uint256 projectId = hook.PROJECT_ID();\n\n        {\n            // Setup the posts.\n            (JB721TierConfig[] memory tiersToAdd, uint256[] memory tierIdsToMint, uint256 totalPrice) =\n                _setupPosts(hook, posts);\n\n            if (projectId != FEE_PROJECT_ID) {\n                // Keep a reference to the fee that will be paid.\n                payValue -= totalPrice / FEE_DIVISOR;\n            }\n\n            // Make sure the amount sent to this function is at least the specified price of the tier plus the fee.\n            if (totalPrice > payValue) {\n                revert CTPublisher_InsufficientEthSent(totalPrice, msg.value);\n            }\n\n            // Add the new tiers.\n            // slither-disable-next-line reentrancy-events\n            hook.adjustTiers(tiersToAdd, new uint256[](0));\n\n            // Keep a reference to the metadata ID target.\n            address metadataIdTarget = hook.METADATA_ID_TARGET();\n\n            // Create the metadata for the payment to specify the tier IDs that should be minted. We create manually the\n            // original metadata, following\n            // the specifications from the JBMetadataResolver library.\n            mintMetadata = JBMetadataResolver.addToMetadata({\n                originalMetadata: additionalPayMetadata,\n                idToAdd: JBMetadataResolver.getId(\"pay\", metadataIdTarget),\n                dataToAdd: abi.encode(true, tierIdsToMint)\n            });\n\n            // Store the referal id in the first 32 bytes of the metadata (push to stack for immutable in assembly)\n            uint256 feeProjectId = FEE_PROJECT_ID;\n\n            assembly {\n                mstore(add(mintMetadata, 32), feeProjectId)\n            }\n        }\n\n        emit Mint({\n            projectId: projectId,\n            hook: hook,\n            nftBeneficiary: nftBeneficiary,\n            feeBeneficiary: feeBeneficiary,\n            posts: posts,\n            postValue: payValue,\n            txValue: msg.value,\n            caller: _msgSender()\n        });\n\n        {\n            // Get a reference to the project's current ETH payment terminal.\n            IJBTerminal projectTerminal = CONTROLLER.DIRECTORY().primaryTerminalOf(projectId, JBConstants.NATIVE_TOKEN);\n\n            // Make the payment.\n            // slither-disable-next-line unused-return\n            projectTerminal.pay{value: payValue}({\n                projectId: projectId,\n                token: JBConstants.NATIVE_TOKEN,\n                amount: payValue,\n                beneficiary: nftBeneficiary,\n                minReturnedTokens: 0,\n                memo: \"Minted from Croptop\",\n                metadata: mintMetadata\n            });\n        }\n\n        // Pay a fee if there are funds left.\n        if (address(this).balance != 0) {\n            // Get a reference to the fee project's current ETH payment terminal.\n            IJBTerminal feeTerminal = CONTROLLER.DIRECTORY().primaryTerminalOf(FEE_PROJECT_ID, JBConstants.NATIVE_TOKEN);\n\n            // Make the fee payment.\n            // slither-disable-next-line unused-return\n            feeTerminal.pay{value: address(this).balance}({\n                projectId: FEE_PROJECT_ID,\n                amount: address(this).balance,\n                token: JBConstants.NATIVE_TOKEN,\n                beneficiary: feeBeneficiary,\n                minReturnedTokens: 0,\n                memo: \"\",\n                metadata: feeMetadata\n            });\n        }\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Setup the posts.\n    /// @param hook The NFT hook on which the posts will apply.\n    /// @param posts An array of posts that should be published as NFTs to the specified project.\n    /// @return tiersToAdd The tiers that will be created to represent the posts.\n    /// @return tierIdsToMint The tier IDs of the posts that should be minted once published.\n    /// @return totalPrice The total price being paid.\n    function _setupPosts(\n        IJB721TiersHook hook,\n        CTPost[] memory posts\n    )\n        internal\n        returns (JB721TierConfig[] memory tiersToAdd, uint256[] memory tierIdsToMint, uint256 totalPrice)\n    {\n        // Set the max size of the tier data that will be added.\n        tiersToAdd = new JB721TierConfig[](posts.length);\n\n        // Set the size of the tier IDs of the posts that should be minted once published.\n        tierIdsToMint = new uint256[](posts.length);\n\n        // The tier ID that will be created, and the first one that should be minted from, is one more than the current\n        // max.\n        uint256 startingTierId = hook.STORE().maxTierIdOf(address(hook)) + 1;\n\n        // Keep a reference to the total number of tiers being added.\n        uint256 numberOfTiersBeingAdded;\n\n        // For each post, create tiers after validating to make sure they fulfill the allowance specified by the\n        // project's owner.\n        for (uint256 i; i < posts.length; i++) {\n            // Get the current post being iterated on.\n            CTPost memory post = posts[i];\n\n            // Make sure the post includes an encodedIPFSUri.\n            if (post.encodedIPFSUri == bytes32(\"\")) {\n                revert CTPublisher_EmptyEncodedIPFSUri();\n            }\n\n            // Scoped section to prevent stack too deep.\n            {\n                // Check if there's an ID of a tier already minted for this encodedIPFSUri.\n                uint256 tierId = tierIdForEncodedIPFSUriOf[address(hook)][post.encodedIPFSUri];\n\n                if (tierId != 0) tierIdsToMint[i] = tierId;\n            }\n\n            // If no tier already exists, post the tier.\n            if (tierIdsToMint[i] == 0) {\n                // Scoped error handling section to prevent Stack Too Deep.\n                {\n                    // Get references to the allowance.\n                    (\n                        uint256 minimumPrice,\n                        uint256 minimumTotalSupply,\n                        uint256 maximumTotalSupply,\n                        address[] memory addresses\n                    ) = allowanceFor(address(hook), post.category);\n\n                    // Make sure the category being posted to allows publishing.\n                    if (minimumTotalSupply == 0) {\n                        revert CTPublisher_UnauthorizedToPostInCategory();\n                    }\n\n                    // Make sure the price being paid for the post is at least the allowed minimum price.\n                    if (post.price < minimumPrice) {\n                        revert CTPublisher_PriceTooSmall(post.price, minimumPrice);\n                    }\n\n                    // Make sure the total supply being made available for the post is at least the allowed minimum\n                    // total supply.\n                    if (post.totalSupply < minimumTotalSupply) {\n                        revert CTPublisher_TotalSupplyTooSmall(post.totalSupply, minimumTotalSupply);\n                    }\n\n                    // Make sure the total supply being made available for the post is at most the allowed maximum total\n                    // supply.\n                    if (post.totalSupply > maximumTotalSupply) {\n                        revert CTPublisher_TotalSupplyTooBig(post.totalSupply, maximumTotalSupply);\n                    }\n\n                    // Make sure the address is allowed to post.\n                    if (addresses.length != 0 && !_isAllowed(_msgSender(), addresses)) {\n                        revert CTPublisher_NotInAllowList(_msgSender(), addresses);\n                    }\n                }\n\n                // Set the tier.\n                tiersToAdd[numberOfTiersBeingAdded] = JB721TierConfig({\n                    price: post.price,\n                    initialSupply: post.totalSupply,\n                    votingUnits: 0,\n                    reserveFrequency: 0,\n                    reserveBeneficiary: address(0),\n                    encodedIPFSUri: post.encodedIPFSUri,\n                    category: post.category,\n                    discountPercent: 0,\n                    allowOwnerMint: false,\n                    useReserveBeneficiaryAsDefault: false,\n                    transfersPausable: false,\n                    useVotingUnits: true,\n                    cannotBeRemoved: false,\n                    cannotIncreaseDiscountPercent: false\n                });\n\n                // Set the ID of the tier to mint.\n                tierIdsToMint[i] = startingTierId + numberOfTiersBeingAdded++;\n\n                // Save the encodedIPFSUri as minted.\n                tierIdForEncodedIPFSUriOf[address(hook)][post.encodedIPFSUri] = tierIdsToMint[i];\n            }\n\n            // Increment the total price.\n            totalPrice += post.price;\n        }\n\n        // Resize the array if there's a mismatch in length.\n        if (numberOfTiersBeingAdded != posts.length) {\n            assembly (\"memory-safe\") {\n                mstore(tiersToAdd, numberOfTiersBeingAdded)\n            }\n        }\n    }\n}\n"
			},
			"src/interfaces/ICTPublisher.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {JB721Tier} from \"@bananapus/721-hook/src/structs/JB721Tier.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\n\nimport {CTAllowedPost} from \"../structs/CTAllowedPost.sol\";\nimport {CTPost} from \"../structs/CTPost.sol\";\n\ninterface ICTPublisher {\n    event ConfigurePostingCriteria(address indexed hook, CTAllowedPost allowedPost, address caller);\n    event Mint(\n        uint256 indexed projectId,\n        IJB721TiersHook indexed hook,\n        address indexed nftBeneficiary,\n        address feeBeneficiary,\n        CTPost[] posts,\n        uint256 postValue,\n        uint256 txValue,\n        address caller\n    );\n\n    function FEE_DIVISOR() external view returns (uint256);\n\n    function CONTROLLER() external view returns (IJBController);\n\n    function FEE_PROJECT_ID() external view returns (uint256);\n\n    function tierIdForEncodedIPFSUriOf(address hook, bytes32 encodedIPFSUri) external view returns (uint256);\n\n    function allowanceFor(\n        address hook,\n        uint256 category\n    )\n        external\n        view\n        returns (\n            uint256 minimumPrice,\n            uint256 minimumTotalSupply,\n            uint256 maximumTotalSupply,\n            address[] memory allowedAddresses\n        );\n\n    function tiersFor(\n        address hook,\n        bytes32[] memory encodedIPFSUris\n    )\n        external\n        view\n        returns (JB721Tier[] memory tiers);\n\n    function configurePostingCriteriaFor(CTAllowedPost[] memory allowedPosts) external;\n\n    function mintFrom(\n        IJB721TiersHook hook,\n        CTPost[] memory posts,\n        address nftBeneficiary,\n        address feeBeneficiary,\n        bytes calldata additionalPayMetadata,\n        bytes calldata feeMetadata\n    )\n        external\n        payable;\n}\n"
			},
			"src/structs/CTAllowedPost.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Criteria for allowed posts.\n/// @custom:member hook The hook to which this allowance applies.\n/// @custom:member category A category that should allow posts.\n/// @custom:member minimumPrice The minimum price that a post to the specified category should cost.\n/// @custom:member minimumTotalSupply The minimum total supply of NFTs that can be made available when minting.\n/// @custom:member maxTotalSupply The max total supply of NFTs that can be made available when minting. Leave as 0 for\n/// max.\n/// @custom:member allowedAddresses A list of addresses that are allowed to post on the category through Croptop.\nstruct CTAllowedPost {\n    address hook;\n    uint24 category;\n    uint104 minimumPrice;\n    uint32 minimumTotalSupply;\n    uint32 maximumTotalSupply;\n    address[] allowedAddresses;\n}\n"
			},
			"src/structs/CTPost.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A post to be published.\n/// @custom:member encodedIPFSUri The encoded IPFS URI of the post that is being published.\n/// @custom:member totalSupply The number of NFTs that should be made available, including the 1 that will be minted\n/// alongside this transaction.\n/// @custom:member price The price being paid for buying the post that is being published.\n/// @custom:member category The category that the post should be published in.\nstruct CTPost {\n    bytes32 encodedIPFSUri;\n    uint32 totalSupply;\n    uint104 price;\n    uint24 category;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJB721TiersHook} from \"./IJB721TiersHook.sol\";\nimport {JBDeploy721TiersHookConfig} from \"../structs/JBDeploy721TiersHookConfig.sol\";\n\ninterface IJB721TiersHookDeployer {\n    event HookDeployed(uint256 indexed projectId, IJB721TiersHook hook, address caller);\n\n    function deployHookFor(\n        uint256 projectId,\n        JBDeploy721TiersHookConfig memory deployTiersHookConfig,\n        bytes32 salt\n    )\n        external\n        returns (IJB721TiersHook hook);\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookProjectDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\n\nimport {IJB721TiersHook} from \"./IJB721TiersHook.sol\";\nimport {IJB721TiersHookDeployer} from \"./IJB721TiersHookDeployer.sol\";\nimport {JBDeploy721TiersHookConfig} from \"../structs/JBDeploy721TiersHookConfig.sol\";\nimport {JBLaunchProjectConfig} from \"../structs/JBLaunchProjectConfig.sol\";\nimport {JBLaunchRulesetsConfig} from \"../structs/JBLaunchRulesetsConfig.sol\";\nimport {JBQueueRulesetsConfig} from \"../structs/JBQueueRulesetsConfig.sol\";\n\ninterface IJB721TiersHookProjectDeployer {\n    function DIRECTORY() external view returns (IJBDirectory);\n    function HOOK_DEPLOYER() external view returns (IJB721TiersHookDeployer);\n\n    function launchProjectFor(\n        address owner,\n        JBDeploy721TiersHookConfig memory deployTiersHookConfig,\n        JBLaunchProjectConfig memory launchProjectConfig,\n        IJBController controller,\n        bytes32 salt\n    )\n        external\n        returns (uint256 projectId, IJB721TiersHook hook);\n\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBDeploy721TiersHookConfig memory deployTiersHookConfig,\n        JBLaunchRulesetsConfig memory launchRulesetsConfig,\n        IJBController controller,\n        bytes32 salt\n    )\n        external\n        returns (uint256 rulesetId, IJB721TiersHook hook);\n\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBDeploy721TiersHookConfig memory deployTiersHookConfig,\n        JBQueueRulesetsConfig memory queueRulesetsConfig,\n        IJBController controller,\n        bytes32 salt\n    )\n        external\n        returns (uint256 rulesetId, IJB721TiersHook hook);\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JBDeploy721TiersHookConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JB721InitTiersConfig} from \"./JB721InitTiersConfig.sol\";\nimport {JB721TiersHookFlags} from \"./JB721TiersHookFlags.sol\";\nimport {IJB721TokenUriResolver} from \"../interfaces/IJB721TokenUriResolver.sol\";\n\n/// @custom:member name The NFT collection's name.\n/// @custom:member symbol The NFT collection's symbol.\n/// @custom:member baseUri The URI to use as a base for full NFT URIs.\n/// @custom:member tokenUriResolver The contract responsible for resolving the URI for each NFT.\n/// @custom:member contractUri The URI where this contract's metadata can be found.\n/// @custom:member tiersConfig The NFT tiers and pricing config to launch the hook with.\n/// @custom:member reserveBeneficiary The default reserved beneficiary for all tiers.\n/// @custom:member flags A set of boolean options to configure the hook with.\nstruct JBDeploy721TiersHookConfig {\n    string name;\n    string symbol;\n    string baseUri;\n    IJB721TokenUriResolver tokenUriResolver;\n    string contractUri;\n    JB721InitTiersConfig tiersConfig;\n    address reserveBeneficiary;\n    JB721TiersHookFlags flags;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JBLaunchProjectConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\n\nimport {JBPayDataHookRulesetConfig} from \"./JBPayDataHookRulesetConfig.sol\";\n\n/// @custom:member projectUri Metadata URI to associate with the project. This can be updated any time by the owner of\n/// the project.\n/// @custom:member rulesetConfigurations The ruleset configurations to queue.\n/// @custom:member terminalConfigurations The terminal configurations to add for the project.\n/// @custom:member memo A memo to pass along to the emitted event.\nstruct JBLaunchProjectConfig {\n    string projectUri;\n    JBPayDataHookRulesetConfig[] rulesetConfigurations;\n    JBTerminalConfig[] terminalConfigurations;\n    string memo;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JBLaunchRulesetsConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\n\nimport {JBPayDataHookRulesetConfig} from \"./JBPayDataHookRulesetConfig.sol\";\n\n/// @custom:member projectId The ID of the project to launch rulesets for.\n/// @custom:member rulesetConfigurations The ruleset configurations to queue.\n/// @custom:member terminalConfigurations The terminal configurations to add for the project.\n/// @custom:member memo A memo to pass along to the emitted event.\nstruct JBLaunchRulesetsConfig {\n    uint56 projectId;\n    JBPayDataHookRulesetConfig[] rulesetConfigurations;\n    JBTerminalConfig[] terminalConfigurations;\n    string memo;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JBPayDataHookRulesetConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"@bananapus/core/src/structs/JBFundAccessLimitGroup.sol\";\nimport {JBSplitGroup} from \"@bananapus/core/src/structs/JBSplitGroup.sol\";\n\nimport {JBPayDataHookRulesetMetadata} from \"./JBPayDataHookRulesetMetadata.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active – any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a decayed `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member weightCutPercent A percent by how much the `weight` of the subsequent ruleset should be reduced, if\n/// the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_WEIGHT_CUT_PERCENT`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `payoutLimit` and `surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBPayDataHookRulesetConfig {\n    uint48 mustStartAtOrAfter;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    JBPayDataHookRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JBPayDataHookRulesetMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedPercent The reserved percent of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_PERCENT`.\n/// @custom:member cashOutTaxRate The cash out tax rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_CASH_OUT_TAX_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member allowAddAccountingContext A flag indicating if a project can add new accounting contexts for its\n/// terminals to use.\n/// @custom:member allowAddPriceFeed A flag indicating if a project can add new price feeds to calculate exchange rates\n/// between its tokens.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForCashOut A flag indicating if cash outs should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the cash out is being fulfilled.\n/// @custom:member useDataHookForCashOuts A flag indicating if the data hook should be used for cash out transactions\n/// during\n/// this ruleset.\n/// @custom:member metadata Metadata of the metadata, up to uint8 in size.\nstruct JBPayDataHookRulesetMetadata {\n    uint16 reservedPercent;\n    uint16 cashOutTaxRate;\n    uint32 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowSetController;\n    bool allowAddAccountingContext;\n    bool allowAddPriceFeed;\n    bool ownerMustSendPayouts;\n    bool holdFees;\n    bool useTotalSurplusForCashOuts;\n    bool useDataHookForCashOut;\n    uint16 metadata;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JBQueueRulesetsConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPayDataHookRulesetConfig} from \"./JBPayDataHookRulesetConfig.sol\";\n\n/// @custom:member projectId The ID of the project to launch rulesets for.\n/// @custom:member rulesetConfigurations The ruleset configurations to queue.\n/// @custom:member terminalConfigurations The terminal configurations to add for the project.\n/// @custom:member memo A memo to pass along to the emitted event.\nstruct JBQueueRulesetsConfig {\n    uint56 projectId;\n    JBPayDataHookRulesetConfig[] rulesetConfigurations;\n    string memo;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
			},
			"src/CTDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {IJB721TiersHookProjectDeployer} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHookProjectDeployer.sol\";\nimport {IJB721TokenUriResolver} from \"@bananapus/721-hook/src/interfaces/IJB721TokenUriResolver.sol\";\nimport {JB721InitTiersConfig} from \"@bananapus/721-hook/src/structs/JB721InitTiersConfig.sol\";\nimport {JB721TierConfig} from \"@bananapus/721-hook/src/structs/JB721TierConfig.sol\";\nimport {JB721TiersHookFlags} from \"@bananapus/721-hook/src/structs/JB721TiersHookFlags.sol\";\nimport {JBDeploy721TiersHookConfig} from \"@bananapus/721-hook/src/structs/JBDeploy721TiersHookConfig.sol\";\nimport {JBLaunchProjectConfig} from \"@bananapus/721-hook/src/structs/JBLaunchProjectConfig.sol\";\nimport {JBPayDataHookRulesetConfig} from \"@bananapus/721-hook/src/structs/JBPayDataHookRulesetConfig.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\nimport {JBConstants} from \"@bananapus/core/src/libraries/JBConstants.sol\";\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\n\nimport {ICTDeployer} from \"./interfaces/ICTDeployer.sol\";\nimport {ICTPublisher} from \"./interfaces/ICTPublisher.sol\";\nimport {CTAllowedPost} from \"./structs/CTAllowedPost.sol\";\nimport {CTDeployerAllowedPost} from \"./structs/CTDeployerAllowedPost.sol\";\n\n/// @notice A contract that facilitates deploying a simple Juicebox project to receive posts from Croptop templates.\ncontract CTDeployer is ERC2771Context, IERC721Receiver, ICTDeployer {\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice The controller that projects are made from.\n    IJBController public immutable override CONTROLLER;\n\n    /// @notice The deployer to launch Croptop recorded collections from.\n    IJB721TiersHookProjectDeployer public immutable override DEPLOYER;\n\n    /// @notice The Croptop publisher.\n    ICTPublisher public immutable override PUBLISHER;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param controller The controller that projects are made from.\n    /// @param deployer The deployer to launch Croptop projects from.\n    /// @param publisher The croptop publisher.\n    constructor(\n        IJBController controller,\n        IJB721TiersHookProjectDeployer deployer,\n        ICTPublisher publisher,\n        address trusted_forwarder\n    )\n        ERC2771Context(trusted_forwarder)\n    {\n        CONTROLLER = controller;\n        DEPLOYER = deployer;\n        PUBLISHER = publisher;\n    }\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @dev Make sure only mints can be received.\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4)\n    {\n        data;\n        tokenId;\n        operator;\n\n        // Make sure the 721 received is the JBProjects contract.\n        if (msg.sender != address(CONTROLLER.PROJECTS())) revert();\n        // Make sure the 721 is being received as a mint.\n        if (from != address(0)) revert();\n        return IERC721Receiver.onERC721Received.selector;\n    }\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Deploy a simple project meant to receive posts from Croptop templates.\n    /// @param owner The address that'll own the project.\n    /// @param terminalConfigurations The terminals that the network uses to accept payments through.\n    /// @param projectUri The metadata URI containing project info.\n    /// @param allowedPosts The type of posts that the project should allow.\n    /// @param contractUri A link to the collection's metadata.\n    /// @param name The name of the collection where posts will go.\n    /// @param symbol The symbol of the collection where posts will go.\n    /// @param salt A salt to use for the deterministic deployment.\n    /// @return projectId The ID of the newly created project.\n    /// @return hook The hook that was created.\n    function deployProjectFor(\n        address owner,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string memory projectUri,\n        CTDeployerAllowedPost[] memory allowedPosts,\n        string memory contractUri,\n        string memory name,\n        string memory symbol,\n        bytes32 salt\n    )\n        external\n        returns (uint256 projectId, IJB721TiersHook hook)\n    {\n        JBPayDataHookRulesetConfig[] memory rulesetConfigurations = new JBPayDataHookRulesetConfig[](1);\n        rulesetConfigurations[0].weight = 1_000_000 * (10 ** 18);\n        rulesetConfigurations[0].metadata.baseCurrency = uint32(uint160(JBConstants.NATIVE_TOKEN));\n\n        // Deploy a blank project.\n        (projectId, hook) = DEPLOYER.launchProjectFor({\n            owner: address(this),\n            deployTiersHookConfig: JBDeploy721TiersHookConfig({\n                name: name,\n                symbol: symbol,\n                baseUri: \"ipfs://\",\n                tokenUriResolver: IJB721TokenUriResolver(address(0)),\n                contractUri: contractUri,\n                tiersConfig: JB721InitTiersConfig({\n                    tiers: new JB721TierConfig[](0),\n                    currency: uint32(uint160(JBConstants.NATIVE_TOKEN)),\n                    decimals: 18,\n                    prices: IJBPrices(address(0))\n                }),\n                reserveBeneficiary: address(0),\n                flags: JB721TiersHookFlags({\n                    noNewTiersWithReserves: false,\n                    noNewTiersWithVotes: false,\n                    noNewTiersWithOwnerMinting: false,\n                    preventOverspending: false\n                })\n            }),\n            launchProjectConfig: JBLaunchProjectConfig({\n                projectUri: projectUri,\n                rulesetConfigurations: rulesetConfigurations,\n                terminalConfigurations: terminalConfigurations,\n                memo: \"Deployed from Croptop\"\n            }),\n            controller: CONTROLLER,\n            salt: keccak256(abi.encode(salt, _msgSender()))\n        });\n\n        // Configure allowed posts.\n        if (allowedPosts.length > 0) _configurePostingCriteriaFor(address(hook), allowedPosts);\n\n        //transfer to _owner.\n        CONTROLLER.PROJECTS().transferFrom(address(this), owner, projectId);\n    }\n\n    //*********************************************************************//\n    // --------------------- internal transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Configure croptop posting.\n    /// @param hook The hook that will be posted to.\n    /// @param allowedPosts The type of posts that should be allowed.\n    function _configurePostingCriteriaFor(address hook, CTDeployerAllowedPost[] memory allowedPosts) internal {\n        // Keep a reference to the number of allowed posts.\n        uint256 numberOfAllowedPosts = allowedPosts.length;\n\n        // Keep a reference to the formatted allowed posts.\n        CTAllowedPost[] memory formattedAllowedPosts = new CTAllowedPost[](numberOfAllowedPosts);\n\n        // Keep a reference to the post being iterated on.\n        CTDeployerAllowedPost memory post;\n\n        // Iterate through each post to add it to the formatted list.\n        for (uint256 i; i < numberOfAllowedPosts; i++) {\n            // Set the post being iterated on.\n            post = allowedPosts[i];\n\n            // Set the formatted post.\n            formattedAllowedPosts[i] = CTAllowedPost({\n                hook: hook,\n                category: post.category,\n                minimumPrice: post.minimumPrice,\n                minimumTotalSupply: post.minimumTotalSupply,\n                maximumTotalSupply: post.maximumTotalSupply,\n                allowedAddresses: post.allowedAddresses\n            });\n        }\n\n        // Set up the allowed posts in the publisher.\n        PUBLISHER.configurePostingCriteriaFor({allowedPosts: formattedAllowedPosts});\n    }\n}\n"
			},
			"src/interfaces/ICTDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {IJB721TiersHookProjectDeployer} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHookProjectDeployer.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\n\nimport {ICTPublisher} from \"./ICTPublisher.sol\";\nimport {CTDeployerAllowedPost} from \"../structs/CTDeployerAllowedPost.sol\";\n\ninterface ICTDeployer {\n    function CONTROLLER() external view returns (IJBController);\n    function DEPLOYER() external view returns (IJB721TiersHookProjectDeployer);\n    function PUBLISHER() external view returns (ICTPublisher);\n\n    function deployProjectFor(\n        address owner,\n        JBTerminalConfig[] calldata terminalConfigurations,\n        string memory projectUri,\n        CTDeployerAllowedPost[] calldata allowedPosts,\n        string memory contractUri,\n        string memory name,\n        string memory symbol,\n        bytes32 salt\n    )\n        external\n        returns (uint256 projectId, IJB721TiersHook hook);\n}\n"
			},
			"src/structs/CTDeployerAllowedPost.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Criteria for allowed posts.\n/// @custom:member category A category that should allow posts.\n/// @custom:member minimumPrice The minimum price that a post to the specified category should cost.\n/// @custom:member minimumTotalSupply The minimum total supply of NFTs that can be made available when minting.\n/// @custom:member maxTotalSupply The max total supply of NFTs that can be made available when minting. Leave as 0 for\n/// max.\n/// @custom:member allowedAddresses A list of addresses that are allowed to post on the category through Croptop.\nstruct CTDeployerAllowedPost {\n    uint24 category;\n    uint104 minimumPrice;\n    uint32 minimumTotalSupply;\n    uint32 maximumTotalSupply;\n    address[] allowedAddresses;\n}\n"
			},
			"src/CTProjectOwner.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {JBPermissionsData} from \"@bananapus/core/src/structs/JBPermissionsData.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {ICTProjectOwner} from \"./interfaces/ICTProjectOwner.sol\";\nimport {ICTPublisher} from \"./interfaces/ICTPublisher.sol\";\n\n/// @notice A contract that can be sent a project to be burned, while still allowing croptop posts.\ncontract CTProjectOwner is IERC721Receiver, ICTProjectOwner {\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice The contract where operator permissions are stored.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    /// @notice The contract from which project are minted.\n    IJBProjects public immutable override PROJECTS;\n\n    /// @notice The Croptop publisher.\n    ICTPublisher public immutable override PUBLISHER;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions The contract where operator permissions are stored.\n    /// @param projects The contract from which project are minted.\n    /// @param publisher The Croptop publisher.\n    constructor(IJBPermissions permissions, IJBProjects projects, ICTPublisher publisher) {\n        PERMISSIONS = permissions;\n        PROJECTS = projects;\n        PUBLISHER = publisher;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Give the croptop publisher permission to post to the project on this contract's behalf.\n    /// @dev Make sure to first configure certain posts before sending this contract ownership.\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    )\n        external\n        override\n        returns (bytes4)\n    {\n        data;\n        from;\n        operator;\n\n        // Make sure the 721 received is the JBProjects contract.\n        if (msg.sender != address(PROJECTS)) revert();\n\n        // Set the correct permission.\n        uint8[] memory permissionIds = new uint8[](1);\n        permissionIds[0] = JBPermissionIds.ADJUST_721_TIERS;\n\n        // Give the croptop contract permission to post on this contract's behalf.\n        PERMISSIONS.setPermissionsFor({\n            account: address(this),\n            permissionsData: JBPermissionsData({\n                operator: address(PUBLISHER),\n                projectId: uint56(tokenId),\n                permissionIds: permissionIds\n            })\n        });\n\n        return IERC721Receiver.onERC721Received.selector;\n    }\n}\n"
			},
			"src/interfaces/ICTProjectOwner.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\n\nimport {ICTPublisher} from \"./ICTPublisher.sol\";\n\ninterface ICTProjectOwner {\n    function PERMISSIONS() external view returns (IJBPermissions);\n    function PROJECTS() external view returns (IJBProjects);\n    function PUBLISHER() external view returns (ICTPublisher);\n}\n"
			}
		}
	}
}